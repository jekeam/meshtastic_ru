---
id: comments
title: Комментарии к шифрованию Meshtastic
sidebar_label: Комментарии
sidebar_position: 2
description: "Explore community insights and expert opinions on Meshtastic's encryption, including AES256 implementation, security tips, and potential vulnerabilities."
---

import QRCode from "@site/docs/blocks/_qr-code.mdx";

Эта страница собирает отзывы сообщества и экспертные обзоры по подходу Meshtastic к шифрованию. Мы ценим эти замечания и улучшаем реализацию там, где это возможно. Узнайте ключевые детали, практические советы и поймите сильные и слабые стороны шифрования AES256 в Meshtastic.

## Комментарии {#comments}

Криптография сложна, поэтому мы постарались просто применить стандартные решения. Однако разработчики проекта не являются криптографами.

С учётом комментариев ревьюеров (см. ниже), вот советы по использованию этих радиостанций, чтобы понимать уровень защиты:

- Скорее всего, безопасность AES256 реализована корректно, и наблюдатель не сможет декодировать ваши сообщения.
- Внимание: если атакующий получит одно из радио, он сможет: а) извлечь ключ канала с устройства, или б) использовать это радио для прослушивания новых сообщений.
- Внимание: если атакующий получит "Channel QR[^1] code/URL", которым вы делитесь с другими, он сможет читать любые сообщения в канале (как будущие, так и прошедшие — если у него сохранены сырые копии тех широковещательных пакетов).

[^1]:
    <QRCode />

Текущая реализация обеспечивает опциональную конфиденциальность для участников настроенной сети:

- Шифрование выполняется на устройствах/узлах с общесетевыми ключами шифрования.
- Шифрование опционально и отключается в 'Ham mode'.
- В клиентах (iOS, Android) шифрования нет — для упрощения распространения как массового ПО.
- Привязка клиент→устройство выполняется через:
  - Прямое USB-подключение
  - Паринг по Bluetooth
- Устройства "promiscuous" и привязываются к любому ближайшему клиенту. Конфиденциальность сети требует физической защиты всех узлов.

Всегда помните о заметке xkcd про шифрование: https://xkcd.com/538.

- Если вы эксперт по криптографии, посмотрите наши заметки и вопросы ниже. Готовы принять советы и указать авторство в любом объёме ;-).
- Считайте текущую реализацию стадией 'alpha', вероятно достаточно защищённой от не слишком агрессивного противника (но более уверенно пока сказать не можем).

## Заметки для ревьюеров {#notes-for-reviewers}

Если вы проверяете нашу реализацию, кратко о методе:

- Вся криптография — только на уровне SubPacket (payload), чтобы все узлы Meshtastic могли маршрутизировать чужие пакеты — даже каналы, зашифрованные ключом, которого у узла нет.
- В основном опираемся на [Wikipedia](https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Counter_(CTR)) и режимы, которые ESP32 аппаратно поддерживает.
- Используем AES256-CTR как поточный шифр (с нулевым дополнением последнего BLOCK), потому что он хорошо ускоряется железом.
- Ключ AES — 128 или 256 бит, распространяется как часть спецификации 'Channel'.
- В качестве NONCE используем конкатенацию номера узла и номера пакета. NONCE хранится во flash и по сути не должен повторяться. Если пользователь создаёт новый 'Channel' (то есть выбирает новый случайный 256‑битный ключ), номер пакета стартует с нуля.
- Номер пакета отправляется в открытом виде в каждом пакете. Номер узла можно получить из поля "from" каждого пакета. (Открытый вид допустим, потому что это лишь IV для каждого запуска шифрования)
- Каждый 16‑байтный BLOCK пакета имеет инкрементируемый COUNTER. COUNTER начинается с нуля для первого блока каждого пакета.
- IV для каждого блока строится конкатенацией: верхние 96 бит — это NONCE, нижние 32 бита — COUNTER. Так как пакеты у нас маленькие, счётчик практически никогда не превысит 32 (5 бит).

### Комментарии от ревьюера №1 {#comments-from-reviewer-1}

Этот ревьюер — криптограф-практик, но хочет остаться анонимным. Спасибо за комментарии ;-):

Предположу, что Meshtastic используют в походах и местах, где кто-то способный может пытаться её ломать — как если бы вы ходили с ней по DefCon. Я потратил около часа на обзор шифрования и вот мои заметки:

- Описание менее ясное, чем код.
- Код корректно использует режим AES-CTR для обеспечения конфиденциальности.
- Комментарий к initNonce действительно содержит необходимую информацию.
- Важнее вопрос "что именно должно обеспечивать шифрование"? Пока устройство не захвачено, атакующий вряд ли сможет получить текст или координаты. Захватив любое устройство в канале/mesh, атакующий сможет читать всё, что идёт на это устройство, всё, что на нём сохранено, и любую другую связь в канале, которую он перехватил в зашифрованном виде. Если это соответствует вашим ожиданиям и задачам — на основе публичной информации шифрование ок. Если эти свойства нежелательны (например, история устройства нарочно ограничена, и вы не хотите, чтобы устройство, захваченное сегодня, ставило под угрозу данные, отправленные вчера), можно обсудить пути решения (скорее всего синхронизация времени и замена ключа на его SHA256 каждые X часов, гарантируя, что старый ключ не хранится без надобности).
- Ещё два момента: AES-CTR сам по себе не даёт аутентичности (например, атакующий может флипать биты при повторе пакета и портить расшифрованный текст), и текущая схема выдаёт некоторые подсказки о передаче по размеру. Если вас волнует преднамеренная порча сообщений или раскрытие длины текста, это, похоже, возможно.

Полагаю, сеть работает примерно как сеть store-and-forward — или, по крайней мере, цель — избегать установки двустороннего соединения для передачи данных. С mesh‑сетями я мало работал, лишь немного изучал их в вузе лет десять назад.

### Комментарии от @Jorropo {#comments-from-jorropo}

- Инициализация IV использует лишь 31 случайный бит на перезагрузку, дальше сообщения инкрементируются последовательно. Это немного: дубликаты маловероятны, но возможны в масштабе всей сети. К счастью, IV включает младшие 32 бита MAC‑адреса, которые должны быть уникальны на узел, так что у каждого узла свой "парадокс дней рождения", а не сетевой — который было бы легко атаковать. См. [`#4031`](https://github.com/meshtastic/firmware/issues/4031).
  Можно исправить.
- Отсутствие [контроля целостности учтено недостаточно](https://github.com/meshtastic/firmware/issues/4030): модуль удалённого администрирования выполняет привилегированные RPC поверх AES-CTR без MAC или AEAD.
  Можно исправить.
- Реализация AES-CTR, похоже, защищает конфиденциальность при условии отсутствия повторов IV.
- Отсутствие Forward Secrecy немного тревожит для чат‑мессенджера, особенно когда у новых пользователей нет параноидальной и занудной практики управления ключами, которая требуется для безопасной работы.
- ИМХО, клиенты должны показывать большой красный баннер при первом открытии Direct-Message: это не приватно и не E2E. Без чтения кода это было неочевидно.
- Проект отлично подходит для общения с незнакомцами, используя дефолтный ключ и понимая, что всё публично. Я бы не доверял ему что‑то приватное без дополнительного слоя или серьёзных доработок. Например, SSH или Signal поверх Meshtastic я бы считал безопасными. И да, Meshtastic не делает крипту хуже "без причины" — так сеть становится заметно более удобной поверх ненадёжного и медленного LoRa backhaul.