---
id: limitations
title: Известные ограничения и планы развития шифрования Meshtastic
sidebar_label: Ограничения и планы
sidebar_position: 3
description: "Заметки о модели шифрования и безопасности Meshtastic, разбор известных ограничений, вытекающих из требований проекта, и планы на будущее."
---

import QRCode from "@site/docs/blocks/_qr-code.mdx";

Модель безопасности Meshtastic находится на пересечении противоречивых требований. Этот документ объясняет эти требования, компромиссы между ними и описывает текущие ограничения, выбранные ради удобства использования Meshtastic. Также здесь отражены недавние изменения и запланированные исправления.

Эта информация не нова, но до сих пор была раскидана по обсуждениям в Discord, задачам на GitHub и комментариям в коде Meshtastic. Этот документ собирает всё в одном месте.

## История {#history}

Изначально Meshtastic был рассчитан только на закрытые доверенные группы. Каналы Meshtastic шифруются с помощью Pre-Shared Key (PSK) и AES-CTR. Такой тип шифрования не включает аутентификацию, поэтому любой, у кого есть PSK, может отправлять сообщения от имени любого пользователя на этом канале.

У AES-CTR есть ещё одна слабость: для заданного Initialization Vector (IV) формируется поток шифрования, а само шифрование — это операция XOR над открытым текстом и этим потоком. В сообщениях канала Meshtastic IV — это комбинация Nodenum отправителя и PacketID данного сообщения. Это означает, что если атакующий может восстановить точный открытый текст зашифрованного сообщения, он может переиспользовать комбинацию Nodenum и PacketID, чтобы отправлять поддельные сообщения, даже не зная PSK канала. Польза от такого приема ограничена требованием повторного использования PacketID и исходного NodeNum для получения совпадающего IV.

В первой итерации Meshtastic обрабатывал Direct Messages (DM) с использованием существующего PSK канала, помечая DM как адресованные конкретной ноде. Это было приемлемо для маленьких групп, но с появлением публичных Mesh-сетей и возможных злоумышленников ситуация изменилась. Около года Meshtastic целенаправленно добавляет функции для усиления защиты в этом сценарии, минимально ломая совместимость.

DM через PSK были признаны проблемой, и в Meshtastic 2.5 появился новый DM. Эта система использует x25519 и AES-CCM для шифрования и аутентификации DM между нодами. Публичные ключи передаются внутри пакетов User, зашифрованных текущими PSK канала.

## Ограничения {#limitations}

Эта система вынужденно использует модель Trust On First Use (TOFU). Нет центрального авторитета, подписывающего пользовательские ключи, поэтому ноды сохраняют и используют первый объявленный публичный ключ для данного номера ноды. Для децентрализованной mesh-сети это фактически жесткое требование.

Проблему усугубляет ограниченная память для хранения нод на устройстве Meshtastic. NodeDB ограничен 100 нодами на большинстве железа; когда в сети появляется больше нод, самая старая и наименее интересная вытесняется из NodeDB, чтобы освободить место. Исключение — ноды, отмеченные как избранные: они гарантированно не удаляются из NodeDB.

Сочетание TOFU и ограниченного железа приводит к проблеме. Когда нода «выпадает» из NodeDB, прошивка Meshtastic не может подтвердить, что будущий пакет User — не подмена этого Node Number с другим публичным ключом. Ситуацию ухудшает то, что атакующий в канале может быстро создавать фейковые ноды и заставлять легитимные ноды раньше выталкиваться из NodeDB.

Эта атака была учтена при проектировании DM и принята как неизбежный результат построения ad-hoc, децентрализованного mesh’а. Снова: нет центрального авторитета для подписи ключей. Поэтому в систему встроили несколько мер, уменьшающих практическую пользу такой атаки.

## Ожидаемое поведение {#intended-behavior}

Во‑первых, хотя NodeDB на встроенном железе ограничен ~100 нодами, подключённый мобильный клиент может хранить данные о гораздо большем числе нод и предупреждать пользователя, если у знакомой ноды появился другой публичный ключ. Так появляется иконка красного ключа рядом с нодой в клиенте: прошивка увидела другой публичный ключ для этой ноды, и клиент знает, что он изменился.

Вторая важная мера: ноды, помеченные как избранные, никогда не удаляются из NodeDB. Клиенты теперь автоматически помечают ноды как избранные при отправке им DM, что дополнительно гарантирует, что собеседник — та же самая нода.

Прошивка meshtastic также поддерживает откат к старому поведению DM. Это строго контролируется через булево поле “pki_encrypted” и байтовое поле “public_key”. Когда прошивка получает пакет из mesh-сети, если пакет отправлен с использованием PKI-шифрования DM, флаг устанавливается в true, а публичный ключ источника копируется в байтовое поле. DM по старой схеме через PSK канала по‑прежнему принимаются и обрабатываются, но pki_encrypted устанавливается в false.

Пакеты, отправляемые подключённым клиентом, могут выставлять булево “pki_encrpyted” в true и заполнять байтовое поле public_key в пакете, отправляемом через локальный API. Если булево поле true, пакет будет отправлен только как PKI DM. Если байты заполнены, пакет будет отправлен только в том случае, если публичный ключ в сообщении API совпадает с публичным ключом этой ноды в локальном NodeDB. Если булево не установлено в true, прошивка отправит пакет как PKI DM, если он действительно адресован одному получателю и прошивка знает публичный ключ цели. Если публичный ключ удалённой ноды неизвестен и флаг pki_encrypted не установлен, исходящие сообщения откатятся к менее безопасному шифрованию канала.

## Будущее с ED25519 {#the-ed25519-future}

Часть слабых мест Meshtastic можно закрыть добавлением подписи сообщений каналов. Поскольку место в NodeDB ограничено, а пакеты LoRa ограничены максимумом в 256 байт, на практике требуется переиспользовать существующие пары public/private ключей и делать подписи как можно короче.

Также неоднократно предлагалось выводить nodeNum из publicKey, чтобы снизить возможность подмены пакета User с существующим nodenum и новым публичным ключом. Команда безопасности Meshtastic в целом согласна с этим подходом, но внедрить его как ломающее совместимость изменение было непрактично. Добавление подписанных сообщений даёт возможность закрепить новый источник nodenum, сохраняя обратную совместимость со старой системой.

Поддержка ED25519 всё ещё финализируется на момент написания, но текущий прототип использует XEdDSA из Signal, чтобы использовать существующие подписи X25519 в виде подписей ED25519. Это серьёзно улучшает гарантии безопасности в Meshtastic, но такие подписи имеют размер 64 байта, что заметно при ограниченном размере сообщений LoRa.

После того как нода успешно подпишет сообщение User по этой схеме, в битовом поле NodeInfoLite устанавливается бит HAS_XEDDSA_SIGNED, который транслируется в булево has_xeddsa_signed в сообщении NodeInfo.

Как только этот бит установлен, неподписанные user‑пакеты от этого источника будут отбрасываться. Остаётся определить, как поступать с другими неподписанными пакетами. На данный момент рекомендация: короткие пакеты, которые могут быть подписаны, следует отбрасывать, если они не подписаны.