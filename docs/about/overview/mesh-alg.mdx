---
id: mesh-algo
title: Алгоритм вещания Mesh
slug: /overview/mesh-algo
sidebar_label: Алгоритм Mesh
sidebar_position: 2
description: "Алгоритм вещания Mesh в Meshtastic: эффективный протокол маршрутизации для автономной связи на LoRa."
---

import ReactPlayer from "react-player";

## Текущий алгоритм {#current-algorithm}

Протокол маршрутизации Meshtastic рассчитан на самые разные сценарии. Главное — он не предполагает только статичные узлы. Хотите проверить теоретическую производительность? Посмотрите [симулятор](https://github.com/GUVWAF/Meshtasticator). На протокол сильно повлиял алгоритм mesh‑маршрутизации из [RadioHead](https://www.airspayce.com/mikem/arduino/RadioHead) (использовался в ранних версиях проекта). У него четыре концептуальных слоя и (с версии 2.6) разные подходы для широковещания и прямых сообщений.

<div style={{ maxWidth: "800px", margin: "auto" }}>
  <ReactPlayer
    url="https://youtu.be/7v6UbC5blJU"
    controls
    width="100%"
    height="400px"
  />
</div>

### Пару слов о Protocol Buffers {#a-note-about-protocol-buffers}

Чтобы устройства работали между разными вендорами и реализациями, мы повсеместно используем [Protocol Buffers](https://github.com/meshtastic/protobufs). В контексте этого документа важно учитывать типы сообщений MeshPacket и Sub-packet.

### Уровень 0: LoRa-радио {#layer-0-lora-radio}

Все данные преобразуются в символы LoRa и отправляются в радио для передачи. Детали описаны в другом месте, но важно, что помимо байтов пакета, описанных ниже, в начале каждого пакета данных отправляется преамбула.

Эта преамбула позволяет принимающим радиомодулям синхронизировать часы и начать фрейминг. Мы используем длину преамбулы 16 (больше минимальной 8), чтобы приёмники SX126x LoRa могли спать дольше и экономить энергию.

После преамбулы идёт LoRa Physical Header, который содержит длину пакета и sync word для разделения сетей. Для Meshtastic это `0x2B`.

### Уровень 1: Ненадёжные сообщения (zero hop) {#layer-1-unreliable-zero-hop-messaging}

Это обычная ненадёжная передача пакетов LoRa. Пакет, сформированный устройством Meshtastic, перед кодированием выглядит так:

| Смещение |                  Длина                  |   Тип   | Назначение                                                                                               |
| :------: | :-------------------------------------: | :-----: | :-------------------------------------------------------------------------------------------------------- |
|  0x00    |                 4 байта                 | Integer | Заголовок пакета: Destination. Уникальный NodeID получателя. `0xFFFFFFFF` для broadcast. Little Endian.  |
|  0x04    |                 4 байта                 | Integer | Заголовок пакета: Sender. Уникальный NodeID отправителя. Little Endian.                                  |
|  0x08    |                 4 байта                 | Integer | Заголовок пакета: уникальный ID пакета у отправителя. Little Endian.                                     |
|  0x0C    |                 1 байт                  |  Биты   | Заголовок пакета: флаги. См. [флаги заголовка](#packet-header-flags).                                    |
|  0x0D    |                 1 байт                  |  Биты   | Заголовок пакета: хеш Channel. Подсказка для расшифровки на приёмнике.                                   |
|  0x0E    |                 1 байт                  |  Байты  | Заголовок пакета: Next-hop для ретрансляции.                                                             |
|  0x0F    |                 1 байт                  |  Байты  | Заголовок пакета: узел-ретранслятор текущей передачи.                                                    |
|  0x10    | Макс. 237 байт (без накладных protobuf) |  Байты  | Данные пакета. Незаполненные байты не передаются.                                                        |

#### Флаги заголовка пакета {#packet-header-flags}

| Индекс | # бит | Назначение                         |
| :----: | :---: | :--------------------------------- |
|   0    |   3   | HopLimit (см. примечание в Уровне 3) |
|   3    |   1   | WantAck                           |
|   4    |   1   | ViaMQTT (пакет пришёл через MQTT) |
|   5    |   3   | HopStart (исходный HopLimit)      |

#### Подробности использования {#usage-details}

- Packet Header: описан классом `PacketHeader` в исходниках C++. По сути соответствует началу protobuf‑структуры `MeshPacket`. Заголовок не кодируется через protobuf, а отправляется сырыми байтами. Это экономит эфир и позволяет радиомодулю приёмника фильтровать пакеты до пробуждения основного CPU.

- Packet Header — NodeIDs: берутся из младших четырёх байт Bluetooth MAC‑адреса. Так как OUI назначается IEEE, а мы поддерживаем немного CPU‑вендоров, старший байт де‑факто уникален для каждого вендора. Младшие 3 байта гарантированно уникальны у вендора.

- Packet Header — Unique ID: 32‑битный ID, чтобы обеспечить достаточно уникального состояния для защиты шифрованной полезной нагрузки от атак.

- Payload: зашифрованный и упакованный protobuf `SubPacket`. Шифруется только `SubPacket`, заголовки — нет. Это позволяет маршрутизировать пакеты, не зная содержимого. Подробнее см. [encryption](/docs/overview/encryption) и [Protobuf API Reference](https://buf.build/meshtastic/protobufs/). Данные длиннее максимума обрезаются.

#### CSMA/CA (множественный доступ с прослушиванием и избежанием коллизий) {#carrier-sense-multiple-access-with-collision-avoidance-csma-ca}

Meshtastic использует CSMA/CA, как в Wi‑Fi. Перед передачей узел выполняет CAD (Channel Activity Detection). Если канал занят — ждёт освобождения. Так как при освобождении канала сразу несколько узлов могут начать передачу, узел ждёт случайное число слотов. Величина слота — время, нужное для CAD. Количество слотов выбирается случайно из окна конкуренции (CW), размер которого зависит от загрузки канала. Чем выше загрузка, тем больше CW, чтобы уменьшить коллизии.

### Уровень 2: Надёжные сообщения (zero hop) {#layer-2-reliable-zero-hop-messaging}

Этот слой добавляет надёжную доставку между узлом и его ближайшими соседями.

Поведение Уровня 1 расширяется установкой флага `WantAck` в protobuf `MeshPacket`. Если `WantAck` установлен, действует следующее из mesh.proto:

> Пакет отправляется как надёжное сообщение — нам важно, чтобы он дошёл до адресата. Мы хотим получить в ответ пакет ACK.
>
> Для широковещания этот флаг обрабатывается особым образом: так как ACK для broadcast быстро забьют канал, обычные ACK подавляются. Вместо этого исходный отправитель слушает эфир: если хоть один узел перебросил (rebroadcast) этот пакет (из‑за наивного flooding‑алгоритма), то с большой вероятностью (для типичной LoRa‑топологии) сообщение в итоге дойдёт до всех узлов. Поэтому FloodingRouter.cpp генерирует неявный ACK и доставляет его исходному отправителю. Если за какое‑то время мы не слышим переброса нашего пакета, истекает таймаут и мы переотправляем, используя обычную логику ретраев.

Если передающий узел не получает ACK (или NAK) за время ожидания, он снова отправит пакет через Уровень 1. Надёжный пакет (на уровне “zero hop”) переотправляется максимум три раза. Если к тому моменту ACK/NAK не пришёл, локальный узел внутренне сгенерирует NAK (для локального использования или для верхних слоёв протокола). Таймаут переотправки основан на максимальном времени прихода (неявного) ACK с учётом эфирного времени пакета и задержек обработки.
Для прямых сообщений конечный получатель также отправит настоящий ACK обратно исходному отправителю, но устройство будет ретранслировать только если вообще не получило ACK.

### Уровень 3: Multi-Hop сообщения {#layer-3-multi-hop-messaging}

## Широковещание через Managed Flooding {#broadcasts-using-managed-flooding}

С учётом разных сценариев Meshtastic опирается на [flooding](<https://en.wikipedia.org/wiki/Flooding_(computer_networking)>): каждый узел перебрасывает полученный пакет до определённого лимита прыжков. Важное отличие — перед перебросом узел короткое время слушает эфир: если другой уже перебросил тот же пакет, он не будет повторять. Поэтому корректнее говорить “Managed Flooding”.

Принцип таков. Любой узел сети, увидев пакет с HopLimit больше нуля, декрементирует HopLimit и пытается перебросить его от имени исходного отправителя. Чтобы дать шанс более дальним узлам перебрасывать первыми (и продвинуть сообщение дальше), окно конкуренции (CW, см. Уровень 1) для flooding зависит от SNR принятого пакета. При низком SNR CW мало — дальше стоящие узлы с большей вероятностью перебросят первыми, а ближние, услышав это, воздержатся. Исключение — роли `ROUTER` и `REPEATER`: у них повышенный приоритет, они перебросят даже если слышат переброс другого узла.

### Пример {#example}

Ниже пример топологии из четырёх узлов в режиме `CLIENT`. В какой‑то момент узел 0 отправляет broadcast.
Из‑за зоны покрытия его слышат только узлы 1 и 2. Так как узел 2 дальше, его SNR ниже, и он начинает переброс раньше 1.
После того как узел 0 услышал этот переброс, его сообщение считается подтверждённым. Подтверждение засчитывается, как только получен переброс от любого узла Meshtastic (даже с другим ключом шифрования).
Узел 1 услышал переброс от 2 и сам больше не перебрасывает. Узел 3 слышит сообщение впервые и HopLimit ещё не ноль — он начинает переброс для потенциальных других получателей.

![Пример алгоритма Mesh](/img/SNR_based_flooding.webp)

## Прямые сообщения через маршрутизацию Next-Hop {#direct-messages-using-next-hop-routing}

С версии 2.6 Meshtastic использует другой подход для прямых сообщений. Сначала применяется описанный выше managed flooding, чтобы достичь получателя.
Затем мы отслеживаем узлы, которые пытались ретранслировать пакет за нас. Если при успешной доставке приходит ответ (например, NodeInfo, acknowledgment или traceroute), и узел, который ретранслировал ответ к вам, был также одним из ретрансляторов исходного пакета, он отмечается как next-hop. Это значит, что вместо попыток всех узлов ретранслировать пакет будет делать это только узел, чей байт next-hop совпадает. Это определяется для каждого прыжка отдельно, поэтому при асимметричной связи или промежуточном узле на старой Firmware на этом прыжке снова будет использован managed flooding. Если узел движется или меняются RF‑условия, next-hop может стать невалидным. Поэтому на последней попытке ретрансляции узел всегда откатывается к managed flooding, если не слышит свой next-hop.
Процедура показана на диаграмме:

![Процедура маршрутизации Next-Hop](/img/blog/NextHopRouting.webp)

### Регулярные интервалы широковещания {#regular-broadcast-intervals}

Без дополнительных модулей узлы регулярно отправляют три типа трафика:

1. Device Telemetry
   - Управляется `telemetry.device_update_interval`
   - По умолчанию: 30 минут
2. Position
   - Управляется `position.position_broadcast_secs`
   - По умолчанию: 15 минут* (при включённом [smart broadcast](/docs/configuration/radio/position/#smart-broadcast))
3. NodeInfo user
   - Управляется `device.node_info_broadcast_secs`
   - По умолчанию: 3 часа

По мере роста сети и конкуренции за эфир прошивка увеличивает эти интервалы. Это дополняет ограничения по duty cycle, Channel и использованию эфирного времени.

Начиная с версии 2.4.0, для сетей больше 40 узлов (узлы, замеченные за последние 2 часа) прошивка масштабирует интервалы Telemetry, Position и другого вспомогательного трафика портов по формуле:

`ScaledInterval = Interval * (1.0 + ((NumberOfOnlineNodes - 40) * 0.075))`

Например, для активной сети из 62 узлов `telemetry.device_update_interval` будет увеличен до 79.5 минут вместо стандартных 30.